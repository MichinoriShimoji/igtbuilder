<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IGT Builder: Excel → 3/4行インターリニアグロス（Word出力つき）</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js">
// Render gloss cell: only ALL-CAPS tokens become small-caps; others unchanged.
function renderGlossCell(s){
  if(s==null) return "";
  // Split by hyphen/equals but keep delimiters
  const parts = String(s).split(/([\-=.])/);
  const out = [];
  for(let i=0;i<parts.length;i++){
    const seg = parts[i];
    if(seg==null) continue;
    if(seg === '-' || seg === '=' || seg === '.'){ out.push(seg); continue; }
    const tok = seg.replace(/[^A-Za-z0-9]/g, '');
    if(tok && /^[A-Z0-9]+$/.test(tok) && /[A-Z]/.test(tok)){
      // Uppercase token -> show as small-caps (use lowercase text for proper small-caps shape)
      out.push('<span class="abbr-sc">'+ seg.toLowerCase() +'</span>');
    }else{
      // Lowercase lexeme etc. -> as-is
      out.push(seg);
    }
  }
  return out.join('');
}

// Build docx TextRuns for a gloss cell with selective small-caps
function buildGlossRunsDocx(text, TextRun){
  const parts = String(text||'').split(/([\-=.])/);
  const runs = [];
  for(let i=0;i<parts.length;i++){
    const seg = parts[i];
    if(seg==null || seg==='') continue;
    if(seg==='-' || seg==='=' || seg==='.') { runs.push(new TextRun({text:seg})); continue; }
    const tok = seg.replace(/[^A-Za-z0-9]/g, '');
    if(tok && /^[A-Z0-9]+$/.test(tok) && /[A-Z]/.test(tok)){
      runs.push(new TextRun({ text: seg.toLowerCase(), smallCaps: true }));
    }else{
      runs.push(new TextRun({ text: seg }));
    }
  }
  return runs;
}
</script>
  <script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <style>
    :root{ --fg:#222; --muted:#666; --accent:#2962ff; --bg:#fff; --soft:#f5f7fb; --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; --serif: "Noto Serif", "Times New Roman", serif; --sans: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", sans-serif; }
    html,body{margin:0; padding:0; background:var(--soft); color:var(--fg); font-family:var(--sans);} 
    header{background:#fff; position:sticky; top:0; z-index:5; box-shadow:0 1px 0 rgba(0,0,0,.06)}
    .wrap{max-width:1080px; margin:0 auto; padding:20px;}
    h1{font-size:20px; margin:0;}
    .panel{background:#fff; border-radius:14px; box-shadow:0 2px 12px rgba(0,0,0,.05); padding:16px 18px; margin:20px 0;}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
    .row > *{margin:4px 0}
    input[type="file"]{border:1px dashed #bbb; padding:10px; background:#fafafa; border-radius:10px}
    label{font-size:14px; color:var(--muted)}
    button{border:none; background:var(--accent); color:#fff; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600}
    button:disabled{background:#aaa; cursor:not-allowed}
    .quiet{background:#eee; color:#333}
    .note{font-size:13px; color:var(--muted)}
    .grid{display:grid; grid-template-columns:1fr; gap:12px}
    .igt{background:#fff; border-radius:12px; padding:12px 14px; border:1px solid #f0f0f0}
    .igt-table{width:100%; border-collapse:collapse; table-layout:fixed}
    .igt-table td{padding:3px 6px; vertical-align:top; white-space:nowrap}
    .igt-hide-borders td, .igt-hide-borders {border:none}
    .igt-show-borders td{border:1px dashed #ddd}
    .igt-num-td{width:3.2em; text-align:right; color:#333}
    .gloss{font-family:var(--serif); }
    .textline{font-family:var(--mono)}
    .trans{font-family:var(--serif)}
    .mode-group{display:flex; gap:8px}
    .mode-btn{background:#eee; color:#333}
    .mode-btn.active{background:var(--accent); color:#fff}
    .footer{font-size:12px; color:var(--muted); text-align:center; margin:24px 0}
  
  .abbr-sc{ font-variant-caps: all-small-caps; }
</style>
</head>
<body>
  <header>
    <div class="wrap row" style="justify-content:space-between">
      <div>
        <h1>IGT Builder — Excel → 3/4行インターリニアグロス（Word出力対応）</h1>
        <div class="note">
          受理ヘッダ（小文字化して判定）
          <ul style="margin:6px 0 0 18px; padding:0">
            <li>3列: <code>text</code> / <code>gloss</code> / <code>translation</code></li>
            <li>4列: <code>surface|raw|plain|text_raw|原文|表層</code> / <code>text|seg|segtext|text_seg|分割|形態素</code> / <code>gloss|グロス</code> / <code>translation|訳|全文訳|翻訳</code></li>
          </ul>
        </div>
      </div>
      <div id="ingestInfo" class="note"></div>
    </div>
  </header>

  <div class="wrap">
    <div class="panel">
      <div class="row">
        <input id="file" type="file" accept=".xlsx,.xls" /><button class="quiet" id="clearAll">クリア</button>
      </div>
      <div class="row" style="align-items:center">
        <div class="mode-group" role="group" aria-label="IGT行数の選択">
          <button id="mode3" class="mode-btn active" title="原文行なし（3行）">3行グロス</button>
          <button id="mode4" class="mode-btn" title="原文行あり（4行）">4行グロス</button>
        </div>
        <label>フォントサイズ: <input id="fontSize" type="number" value="14" min="10" max="24" style="width:64px"> px</label>
        <label><input type="checkbox" id="toggleBorders"> デバッグ用に罫線を表示</label>
        <label><input type="checkbox" id="forceLower" checked> Word出力時、<b>gloss を小型大文字化</b>（小文字化+SmallCaps）</label>
      </div>
      <div class="row">
        <button id="makeWord" disabled>Word（.docx）をダウンロード</button>
      </div>
    </div>

    <div id="warnings" class="panel" style="display:none"></div>

    <div id="out" class="grid"></div>

    <div class="footer">© IGT Builder. このページはオフラインでも動作します（外部CDNに依存）。</div>
  
    <div id="glossPanel" class="panel" style="display:none"></div>
</div>

<script>
  const state = { examples: [], fontSize: 14, showBorders: false, forceLower: true, mode: '3' };
  // === Embedded Glossary (baked from Excel) ===
  const DEFAULT_MAP = {"ACC": "accusative", "NOM": "nominative", "GEN": "genitive", "DAT": "dative", "TOP": "topic", "COP": "copula", "ERG": "ergative", "ABS": "absolutive", "LOC": "locative", "ALL": "allative", "ABL": "ablative", "INS": "instrumental", "COM": "comitative", "PL": "plural", "SG": "singular", "PRS": "present", "PST": "past", "FUT": "future", "IPFV": "imperfective", "PFV": "perfective", "1SG": "first person singular", "2SG": "second person singular", "3SG": "third person singular", "1PL": "first person plural", "2PL": "second person plural", "3PL": "third person plural"};
  const BAKED_MAP   = {"1.0": "first person", "2.0": "second person", "3.0": "third person", "A": "agent-like argument of canonical transitive verb", "AA": "adverbial adjective", "ABILT": "ability potential", "ABL": "ablative", "ABS": "absolutive form", "ABT": "ability potential", "AC": "adversative conjunction", "ACC": "accusative", "ACOM": "anti-comissive", "ADD": "additive\nadditional", "ADJ": "inflectional adjectival affix", "ADJR": "adjectivizer", "ADJVZ": "adjectivizer", "ADJZ": "adjectivizer", "ADN": "adnominal", "ADNMLZ": "adnominalizer", "ADNZ": "adnominalizer", "ADR": "addressive", "ADT": "additive\nadditional", "ADV": "adverbalizer", "ADVL": "adverbalizer", "ADVR": "adverbalizer", "ADVRS": "adversative", "ADVS": "adversative", "ADVZ": "adverbalizer", "AFF": "affirmative", "AGNR": "agent nominalizer", "AGR": "agreement", "AJLZ": "adjectivizer", "AL": "allative", "ALL": "allative", "ALLOC": "allocutive", "ALZ": "adverbalizer", "AMBG": "ambiguity", "ANT": "anterior", "ANTC": "anticipated future", "ANTIP": "antipassive", "APPL": "applicative", "APPR": "approximate\napproximative", "APPROX": "approximate\napproximative", "APRX": "approximate\napproximative", "ART": "article", "ASC": "associative", "ASP": "aspect", "ASPL": "associative plural", "ASR": "assertive\nassertion", "ASRT": "assertive\nassertion", "ASS": "assertive\nassertion", "ASSPL": "assocative plural", "ASSUM": "assumed evidential", "ATT": "attributive", "ATTR": "attributive", "AUX": "auxiliary", "AVLZ": "adverbalizer", "AVR": "aversive", "AVZ": "adverbalizer", "AZ": "adjectivizer", "BACK": "background", "BEN": "benefactive", "CAP": "capability", "CAS": "causative", "CAUS": "causative", "CC": "cordinate conjunction", "CEX": "counter expression", "CF": "counter factual", "CFM": "confirmation\nconfirmative", "CFP": "clause-final particle", "CHN": "chaining verb", "CIRC": "circumstantial", "CJF": "conjunctive form", "CJP": "conjunctive particle", "CL": "classifier", "CLF": "classifier", "CM": "compound marker", "CMP": "comparative", "CMPL": "complementizer", "CMPR": "comparative", "CNC": "concessive", "CND": "conditional", "CNF": "confirmation\nconfirmative", "CNFM": "confirmation\nconfirmative", "CNG": "complete nagation", "CNJ": "conjunction", "CNS": "consecutive", "CNT": "continuous\ncontinuative", "CNTN": "continuous\ncontinuative", "CNTR": "contrastive", "COH": "", "COM": "comitative", "COMP": "comparative", "COMPL": "completive", "COMPR": "comparative", "CON": "conative", "CONC": "concessive", "CONCES": "concessive", "CONCESS": "concessive", "COND": "conditional", "CONF": "confirmation\nconfirmative", "CONJ": "conjunction\nconjunctive", "CONJEC": "conjecture", "CONT": "continuous\ncontinuative", "COP": "copula", "COR": "corrective", "CORE": "core argument", "CP": "complement", "CPL": "completive", "CPLF": "completive", "CPOT": "capable potential", "CRCM": "circumstantial", "CRTN": "certainty", "CSL": "causal", "CSS": "concessive", "CSV": "concessive", "CTX": "contextual", "CVB": "converb", "D": "determiner", "DAS": "desirious\ndesiderative", "DAT": "dative", "DBT": "doubt", "DE": "direct evidential", "DEC": "declarative", "DECL": "declarative", "DEF": "definitive", "DEM": "demonstrative", "DES": "desirious\ndesiderative", "DESID": "desirious\ndesiderative", "DET": "determiner", "DFOC": "defocus", "DHD": "dummy head", "DIM": "diminutive", "DIMIN": "diminutive", "DIR": "directional verb", "DIRC": "directive\ndirectional", "DIREV": "direct evidential", "DIS": "distal", "DISC": "discourse marker", "DISJ": "disjunctive", "DIST": "distal", "DISTR": "distributive", "DM": "discourse marker", "DOUBT": "doubt", "DRG": "derogative", "DSC": "discourse marker", "DSR": "desiderative", "DU": "dual", "DUB": "dubitative", "DUR": "durative", "DVLZ": "deverbalizer", "E": "epenthetic morpheme", "ECHO": "echo element", "EMO": "emotional", "EMP": "emphatic\nemphasis", "EMPH": "emphatic\nemphasis", "ENDO": "endocentric", "ENU": "enumerative", "EPI": "epistemic", "ERG": "ergative", "ESS": "essive", "EVID": "evidential", "EVD": "evidential", "EXCL": "exclusive", "EXCLAM": "exclamative", "EXCLM": "exclamative", "EXL": "exaltive", "EXM": "exemplative", "EXO": "exocentric", "EXP": "explanation", "EXPER": "experiential", "EXPL": "exemplative", "F": "feminine", "FAM": "familiar", "FIL": "filler", "FILL": "filler", "FMN": "fomal noun", "FIN": "finite", "FL": "filler", "FN": "fomal noun", "FNS": "", "FNT": "finite", "FOC": "focus", "FP": "final particle", "FRN": "formal", "FUT": "future", "GN": "genitive", "GEN": "genitive", "GER": "gerund", "GOL": "goal", "HAB": "habitual", "HABIT": "habitual", "HBT": "habitual", "HES": "hesitation", "HMB": "humble", "HON": "honorific", "HONV": "honorific verb", "HOR": "hortative", "HORT": "hortative", "HS": "hearsay", "HSY": "hearsay", "HUM": "humble", "HUMV": "humble verb", "HYP": "hypothesical", "ICP": "inceptive", "ILST": "illustrative", "IM": "interrogative mood", "IMP": "imperative", "IMPF": "imperfective", "IMPRF": "imperfective", "IMPOT": "impotential", "INC": "inclusive", "INCH": "inchoative", "INCHO": "inchoative", "INCL": "inclusive", "IND": "indicative", "INDEF": "indefinite", "INDET": "indefinite", "INDF": "indefinite", "INDFZ": "indefinitizer", "INF": "inferential", "INFER": "inferential", "INFERN": "inferential", "INFR": "inferential", "INGR": "ingressive", "INS": "instrumental", "INST": "instrumental", "INSTR": "instrumental", "INT": "intentional", "INTER": "interrogative", "INTERJ": "interjection", "INTJ": "interjection", "INTR": "intransitive", "IPF": "imperfective", "IPFV": "imperfective", "IPRF": "imperfective", "IRLS": "irrealis", "IRR": "irrealis", "IRREV": "", "ITR": "intrerrogative", "JUDG": "judging", "KP": "kakari particles", "LAT": "lative", "LCTN": "low certainty", "LEN": "lengthening", "LF": "lengthened (infinitival) form", "LIM": "limitative", "LINT": "lexical intransitive", "LMT": "limitative", "LNK": "linker", "LOC": "locative", "LOG": "logophoric", "LST": "listing", "LTR": "lexical transitive", "LV": "light verb", "M": "mood", "MAL": "malefactive", "MAN": "manner", "MED": "medial verb", "MES": "mesioproximal", "MIR": "mirativity\nmirative", "MOD": "modality", "MODAL": "modality", "MOL": "modality", "MRT": "mirativity\nmirative", "MSB": "kakari-musubi", "N": "neuter", "N-": "non-", "NDUR": "non-durative", "NEG": "negation\nnegative", "NFOC": "non-focus", "NHON": "non-honorific", "NL": "nominal", "NLZ": "nominalizer\nnominalization", "NM": "nominative", "NMLZ": "nominalizer\nnominalization", "NMNL": "nominalizer\nnominalization", "NMNLZ": "nominalizer\nnominalization", "NMR": "nominalizer\nnominalization", "NMZ": "nominalizer\nnominalization", "NOM": "nominative", "NONPAST": "non-past", "NPREF": "non-perfective", "NPRF": "non-perfect", "NPST": "non-past", "NR": "nominalizer\nnominalization", "NRT": "narrative", "NSF": "non-subject focus", "NUM": "numeral", "NZ": "nominalizer\nnominalization", "OBJ": "object", "OBL": "obligative", "OBLG": "obligative", "ODN": "ordinary number", "OMP": "onomatopoeia", "OMPT": "onomatopoeia", "ONLY": "only", "ONM": "onomatopoeia", "OPT": "optative", "ORD": "ordinal numbers", "P": "patient-like argument of canonical transitive verb", "PAR": "pragmatic marker", "PARA": "parallel", "PART": "particle", "PASS": "passive", "PAST": "past", "PERF": "perfect", "PF": "perfect", "PFOC": "predicate focus", "PFT": "perfect", "PFV": "perfective", "PFX": "prefix", "PL": "plural", "PLN": "place noun", "PLT": "polite", "PLQ": "polar question", "PLUR": "plural", "PN": "personal name", "POL": "polite", "POS": "possibility", "POSS": "possessive", "POT": "potential", "PPL": "participle", "PR": "prompt", "PREC": "precative", "PRED": "predicative", "PREP": "preparative", "PRES": "present", "PRESUM": "presumptive", "PREV": "previsional", "PRF": "perfect", "PRG": "progressive", "PRH": "prohibitive", "PRM": "permissive", "PROG": "progressive", "PROH": "prohibitive", "PROS": "prospective", "PROSP": "prospective", "PROX": "proximal/proximate", "PRPR": "preparative", "PRS": "prospective", "PRT": "particle", "PRV": "provisional", "PRVSE": "previsional", "PS": "property stem", "PST": "past", "PSU": "persuasive", "PT": "potential", "PTCP": "participle", "PUR": "purposive", "PURP": "purposive", "Q": "question particle/marker", "QP": "question particle", "QT": "quotative", "QUESTION": "question", "QUO": "quotative", "QUOT": "quotative", "Q.W": "question Yes-No", "Q.Y": "question WH", "REASON": "reason", "REC": "recitation", "RECP": "reciprocal", "RED": "reduplication", "REF": "reflexive", "REFL": "reflexive", "REL": "relative", "REP": "reported\nｒeportative", "RES": "reason", "RESP": "respect\nrespectful", "RESTR": "restrictive", "RFL": "reflexive", "RGR": "regret", "RHET": "rhetorical", "RLS": "realis", "RLZ": "relativizer", "RPT": "reported\nｒeportative", "RSL": "resultative", "RSP": "respect\nrespectful", "RST": "restrictive", "S": "single argument of canonical intransitive verb", "SBJ": "subject", "SBJV": "subjunctive", "SE": "stem extender", "SEEM": "seeming", "SEL": "selection\nselective", "SEQ": "sequential", "SF": "sentence final particle", "SFP": "sentence final particle", "SFS": "sentence final suffix", "SG": "singular", "SGS": "suggestive\nsuggestion", "SGST": "suggestive\nsuggestion", "SIM": "simultaneous", "SIMIL": "similative", "SIML": "simultaneous", "SLD": "solidarity", "SLFQ": "self-question", "SOL": "solidarity", "SPC": "special form", "SPNT": "spontateity", "SUP": "supine", "STA": "state verb", "STAT": "stative", "STM": "stem extension", "STV": "stative verb", "SUB": "subsidiary", "SUFF": "suffix", "SUGS": "suggestive\nsuggestion", "SUPP": "suppositional", "TAG": "tag question particle", "TER": "terminative", "TERM": "terminative", "THM": "thematic vowel", "TEM": "temporal", "TEMP": "temporal", "TIM": "time", "TNR": "temporal nominalizer", "TOP": "topic", "TR": "transitive", "TTL": "title", "U": "single argument of intransitive verb", "UMRK": "unmarked verbal affix", "UPDT": "information updater", "VA": "verbal adjective", "VBLZ": "verbalizer", "VBZ": "verbalizer", "VFOC": "verbal focus", "VLZ": "verbalizer", "VOC": "vocative", "VOL": "volitional\nvolitive", "VR": "verbalizer", "VRB": "verbalizer", "VZ": "verbalizer", "WH": "wh question", "WHQ": "wh question", "YNQ": "yes-no question", "-": "affix boudary", "=": "clitic boudary", "+": "stem boundary\ncompoud boundary", "~": "reduplication boundary", "<>": "loanword"};
  let   GLOSS_MAP   = Object.assign({}, DEFAULT_MAP, BAKED_MAP);

  
function collectTags(examples){
  const dict = Object.create(null);
  (examples||[]).forEach(ex=>{
    (ex.glossWords||[]).forEach(word=>{
      if(!word) return;
      word.split(/[-=]/).forEach(p=>{
        p.split('.').forEach(a=>{
          a = (a||'').trim();
          if(!a) return;
          const tok = a.replace(/[^A-Za-z0-9]/g, '');
          if(tok && /^[A-Z0-9]+$/.test(tok) && /[A-Z]/.test(tok)){
            dict[tok] = true;
          }
        });
      });
    });
  });
  return Object.keys(dict).sort();
}
  function renderGlossPanel(){
    const panel = document.getElementById('glossPanel');
    if(!panel) return;
    const tags = collectTags(state.examples);
    if(!tags.length){ panel.style.display='none'; panel.innerHTML=''; return; }
    const rows = tags.map(t=>{ const full=(GLOSS_MAP[t]||''); return `<tr><td style="font-variant-caps:all-small-caps">${t.toLowerCase()}</td><td>${full}</td></tr>`; }).join('');
    panel.style.display = '';
    panel.innerHTML = '<b>Gloss List</b><table style="border-collapse:collapse;margin-top:6px"><tbody>'+rows+'</tbody></table>';
  }


  function normalizeHeaders(obj){
    const m = {}; for(const k of Object.keys(obj)) m[k.trim().toLowerCase()] = obj[k];
    const pick = (cands)=>{ for(const key of cands){ if(m[key] != null && String(m[key]).trim() !== '') return String(m[key]).trim(); } return ''; };
    let surface = pick(['surface','raw','plain','text_raw','原文','表層']);
    let text = pick(['text','seg','segtext','text_seg','分割','形態素']);
    let gloss = pick(['gloss','グロス']);
    let translation = pick(['translation','訳','全文訳','翻訳']);
    if(!text && !gloss && !translation){
      const vals = Object.values(m).map(v=>String(v).trim()).filter(v=>v!=='');
      if(vals.length===3){ [text,gloss,translation] = vals; }
      if(vals.length===4){ [surface,text,gloss,translation] = vals; }
    }
    return { surface, text, gloss, translation };
  }

  function splitWords(s){ return s ? s.trim().split(/ +/) : []; }
  function deriveSurfaceWords(surface, textWords, targetLen){
    let sw = splitWords(surface);
    if(sw.length === targetLen) return sw;
    sw = (textWords||[]).map(w => (w||'').replace(/[-=]/g, ''));
    while(sw.length < targetLen) sw.push('');
    if(sw.length > targetLen) sw = sw.slice(0, targetLen);
    return sw;
  }

  function toExamples(rows){
    return rows.map(r=>{
      const {surface, text, gloss, translation} = normalizeHeaders(r);
      const tw = splitWords(text);
      const gw = splitWords(gloss);
      const n = Math.max(tw.length, gw.length);
      while(tw.length<n) tw.push('');
      while(gw.length<n) gw.push('');
      const sw = deriveSurfaceWords(surface, tw, n);
      return { surface, surfaceWords: sw, textWords: tw, glossWords: gw, translation };
    }).filter(ex=> ex.textWords.join('').length+ex.glossWords.join('').length+ex.translation.length>0);
  }

  function chooseBestSheet(wb){
    let best = []; let bestName = '';
    for(const name of wb.SheetNames){
      const ws = wb.Sheets[name];
      const rows = XLSX.utils.sheet_to_json(ws, {defval:''});
      const ex = toExamples(rows);
      if(ex.length > best.length){ best = ex; bestName = name; }
    }
    return {examples: best, name: bestName};
  }

  function setExamples(examples, originLabel){
    state.examples = examples;
    document.getElementById('makeWord').disabled = state.examples.length===0;
    document.getElementById('ingestInfo').textContent = originLabel + (examples.length? ` ／ 取込行数: ${examples.length}` : '');
    buildPreview();
      renderGlossPanel();
}

  function setMode(mode){
    state.mode = mode;
    document.getElementById('mode3').classList.toggle('active', mode==='3');
    document.getElementById('mode4').classList.toggle('active', mode==='4');
    buildPreview();
  }

  function buildPreview(){
    const out = document.getElementById('out');
    out.innerHTML = '';
    out.style.fontSize = state.fontSize + 'px';

    const warnBox = document.getElementById('warnings');
    const warns = [];

    state.examples.forEach((ex, i)=>{
      const ncols = Math.max(ex.textWords.length, ex.glossWords.length, 1);
      if(ex.textWords.length !== ex.glossWords.length){
        warns.push(`(${i+1}) 語数不一致: text=${ex.textWords.length} / gloss=${ex.glossWords.length} → 長い側に合わせます`);
      }

      const table = document.createElement('table');
      table.className = 'igt-table ' + (state.showBorders ? 'igt-show-borders' : 'igt-hide-borders');

      if(state.mode === '4'){
        const tr0 = document.createElement('tr');
        const tdNum0 = document.createElement('td');
        tdNum0.className = 'igt-num-td';
        tdNum0.rowSpan = 4;
        tdNum0.textContent = `(${i+1})`;
        tr0.appendChild(tdNum0);
        for(let c=0;c<ncols;c++){
          const td=document.createElement('td'); td.className='textline'; td.textContent = ex.surfaceWords[c] || ''; tr0.appendChild(td);
        }
        table.appendChild(tr0);
      }

      const tr1 = document.createElement('tr');
      if(state.mode === '3'){
        const tdNum = document.createElement('td'); tdNum.className = 'igt-num-td'; tdNum.rowSpan = 3; tdNum.textContent = `(${i+1})`; tr1.appendChild(tdNum);
      }
      for(let c=0;c<ncols;c++){ const td=document.createElement('td'); td.className='textline'; td.textContent = ex.textWords[c] || ''; tr1.appendChild(td); }
      table.appendChild(tr1);

      const tr2 = document.createElement('tr');
      for(let c=0;c<ncols;c++){ const td=document.createElement('td'); td.className='gloss'; td.textContent = ex.glossWords[c] || ''; tr2.appendChild(td); }
      table.appendChild(tr2);

      const tr3 = document.createElement('tr');
      const td=document.createElement('td'); td.className='trans'; td.colSpan = ncols; td.textContent = ex.translation || '';
      tr3.appendChild(td); table.appendChild(tr3);

      const wrap = document.createElement('div'); wrap.className = 'igt'; wrap.appendChild(table); out.appendChild(wrap);
    });

    if(warns.length){ warnBox.style.display = ''; warnBox.innerHTML = '<b>警告</b><br>'+warns.map(w=>`• ${w}`).join('<br>'); }
    else{ warnBox.style.display = 'none'; warnBox.innerHTML = ''; }
  }

  document.getElementById('file').addEventListener('change', async (ev)=>{
    const f = ev.target.files[0]; if(!f) return;
    const data = await f.arrayBuffer();
    const wb = XLSX.read(data, {type:'array'});
    const {examples, name} = chooseBestSheet(wb);
    setExamples(examples, `Excel: ${f.name}（シート: ${name||'不明'}）`);

    });

  document.getElementById('clearAll').addEventListener('click', ()=> setExamples([], '（未読込）'));
  document.getElementById('fontSize').addEventListener('input', (e)=>{ state.fontSize = parseInt(e.target.value||'14',10); buildPreview(); });
  document.getElementById('toggleBorders').addEventListener('change', (e)=>{ state.showBorders = !!e.target.checked; buildPreview(); });
  document.getElementById('forceLower').addEventListener('change', (e)=>{ state.forceLower = !!e.target.checked; });
  document.getElementById('mode3').addEventListener('click', ()=> setMode('3'));
  document.getElementById('mode4').addEventListener('click', ()=> setMode('4'));

  document.getElementById('makeWord').addEventListener('click', async ()=>{
    if(!state.examples.length) return;
    const { Document, Packer, Paragraph, Table, TableRow, TableCell, BorderStyle, WidthType, TextRun } = docx;
    const children = [];

    state.examples.forEach((ex, i)=>{
      const ncols = Math.max(ex.textWords.length, ex.glossWords.length, 1);
      const rows = [];

      if(state.mode === '4'){
        const span = 4;
        const cells0 = [ new TableCell({ rowSpan: span, borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} }, children: [ new Paragraph({ children: [ new TextRun({ text: `(${i+1})` }) ] }) ] }) ];
        for(let c=0;c<ncols;c++){
          cells0.push(new TableCell({ borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} }, children: [ new Paragraph({ children: [ new TextRun({ text: ex.surfaceWords[c]||'' }) ] }) ] }));
        }
        rows.push(new TableRow({ children: cells0 }));
      }

      const cells1 = [];
      if(state.mode === '3'){
        cells1.push(new TableCell({ rowSpan: 3, borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} }, children: [ new Paragraph({ children: [ new TextRun({ text: `(${i+1})` }) ] }) ] }));
      }
      for(let c=0;c<ncols;c++){
        cells1.push(new TableCell({ borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} }, children: [ new Paragraph({ children: [ new TextRun({ text: ex.textWords[c]||'' }) ] }) ] }));
      }
      rows.push(new TableRow({ children: cells1 }));

      
const cells2 = Array.from({length:ncols}, (_,c)=> new TableCell({
  borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} },
  children: [ new Paragraph({ children: buildGlossRunsDocx(ex.glossWords[c]||'', TextRun) }) ]
}));
rows.push(new TableRow({ children: cells2 }));


      rows.push(new TableRow({ children: [ new TableCell({ columnSpan: ncols, borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} }, children: [ new Paragraph({ children: [ new TextRun({ text: ex.translation||'' }) ] }) ] }) ] }));

      const table = new Table({ width: { size: 100, type: WidthType.PERCENTAGE }, borders: { top:{ style: BorderStyle.NONE }, bottom:{ style: BorderStyle.NONE }, left:{ style: BorderStyle.NONE }, right:{ style: BorderStyle.NONE }, insideHorizontal:{ style: BorderStyle.NONE }, insideVertical:{ style: BorderStyle.NONE } }, rows });
      children.push(new Paragraph({ children: [ new TextRun({ text: '' }) ] }));
      children.push(table);
      children.push(new Paragraph({ children: [ new TextRun({ text: '' }) ] }));
    });

    const doc = new Document({ sections: [] });
    doc.addSection({ properties: {}, children });
    const blob = await docx.Packer.toBlob(doc);
    saveAs(blob, 'igt_from_excel.docx');
  });
</script>

<!-- Fallback Word exporter: additive, does not replace original -->
<script>
(function(){
  if (window.__igt_safe_fallback__) return;
  window.__igt_safe_fallback__ = true;

  function scrapeFromStateOrDOM(){
    try{
      // Prefer state
      if (window.state && Array.isArray(window.state.examples) && window.state.examples.length){
        const mode = (window.state && window.state.mode) || '3';
        return window.state.examples.map(ex => ({...ex, mode}));
      }
    }catch(e){}
    // Fallback to DOM: parse preview tables
    const outEl = document.getElementById('out') || document.body;
    const tables = outEl.querySelectorAll('table');
    const exs = [];
    tables.forEach(tbl=>{
      const rows = Array.from(tbl.querySelectorAll('tr')); if(rows.length<3) return;
      const mode = (rows.length>=4) ? '4' : '3';
      const cells = (tr)=> Array.from(tr.children).map(td=>td.textContent);
      let i=0, surface=[], text=[], gloss=[], trans="";
      if(mode==='4'){ surface = cells(rows[i++]).slice(1); }
      text = cells(rows[i++]).slice(1);
      gloss = cells(rows[i++]);
      trans = (cells(rows[i++])[0]||"");
      exs.push({ surfaceWords: (surface.length?surface:text.map(w=>w.replace(/[-=]/g,''))), textWords: text, glossWords: gloss, translation: trans, mode });
    });
    return exs;
  }

  async function buildDoc(examples, forceLower){
    const { Document, Packer, Paragraph, Table, TableRow, TableCell, BorderStyle, WidthType, TextRun } = docx;
    const children = [];
    examples.forEach((ex, i)=>{
      const ncols = Math.max(ex.textWords.length, ex.glossWords.length, 1);
      const rows = [];
      if(ex.mode==='4'){
        const cells0 = [ new TableCell({ rowSpan: 4, borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} }, children: [ new Paragraph({ children: [ new TextRun({ text: `(${i+1})` }) ] }) ] }) ];
        for(let c=0;c<ncols;c++){ cells0.push(new TableCell({ borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} }, children: [ new Paragraph({ children: [ new TextRun({ text: ex.surfaceWords[c]||'' }) ] }) ] })); }
        rows.push(new TableRow({ children: cells0 }));
      }
      const cells1 = [];
      if(ex.mode==='3'){
        cells1.push(new TableCell({ rowSpan: 3, borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} }, children: [ new Paragraph({ children: [ new TextRun({ text: `(${i+1})` }) ] }) ] }));
      }
      for(let c1=0;c1<ncols;c1++){ cells1.push(new TableCell({ borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} }, children: [ new Paragraph({ children: [ new TextRun({ text: ex.textWords[c1]||'' }) ] }) ] })); }
      // Gloss row with selective small caps
      const cells2 = Array.from({length:ncols}, (_,c)=> new TableCell({
        borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} },
        children: [ new Paragraph({ children: (function(){
          const parts = String(ex.glossWords[c]||'').split(/([\-=.])/);
          const runs = [];
          for(let i=0;i<parts.length;i++){
            const seg = parts[i]; if(!seg) continue;
            if(seg==='-'||seg==='='||seg==='.') { runs.push(new TextRun({text:seg})); continue; }
            const tok = seg.replace(/[^A-Za-z0-9]/g,'');
            if(tok && /^[A-Z0-9]+$/.test(tok) && /[A-Z]/.test(tok)){
              runs.push(new TextRun({ text: (forceLower?seg.toLowerCase():seg.toLowerCase()), smallCaps: true }));
            }else{
              runs.push(new TextRun({ text: seg }));
            }
          }
          return runs;
        })() }) ]
      }));
      rows.push(new TableRow({ children: cells2 }));
      rows.push(new TableRow({ children: [ new TableCell({ columnSpan: ncols, borders: { top:{style:BorderStyle.NONE}, bottom:{style:BorderStyle.NONE}, left:{style:BorderStyle.NONE}, right:{style:BorderStyle.NONE} }, children: [ new Paragraph({ children: [ new TextRun({ text: ex.translation||'' }) ] }) ] }) ] }));
      const table = new Table({ width: { size: 100, type: WidthType.PERCENTAGE }, borders: { top:{ style: BorderStyle.NONE }, bottom:{ style: BorderStyle.NONE }, left:{ style: BorderStyle.NONE }, right:{ style: BorderStyle.NONE }, insideHorizontal:{ style: BorderStyle.NONE }, insideVertical:{ style: BorderStyle.NONE } }, rows });
      children.push(new Paragraph({ children: [ new TextRun({ text: '' }) ] }));
      children.push(table);
      children.push(new Paragraph({ children: [ new TextRun({ text: '' }) ] }));
    });
    const doc = new Document({ sections: [] });
    doc.addSection({ properties: {}, children });
    return await docx.Packer.toBlob(doc);
  }

  document.addEventListener('click', (ev)=>{
    const btn = ev.target.closest && ev.target.closest('#makeWord');
    if(!btn) return;
    // Let original handler run first; if nothing downloaded, run fallback after a small delay
    setTimeout(async ()=>{
      try{
        const examples = scrapeFromStateOrDOM();
        if(!examples || !examples.length) return; // no preview yet
        const forceLower = (document.getElementById('forceLower')||{}).checked !== false;
        const blob = await buildDoc(examples, forceLower);
        saveAs(blob, 'igt_from_excel.docx');
      }catch(e){ console.error('SAFE fallback failed:', e); }
    }, 250);
  }, true);
})();
</script>

</body>
</html>
